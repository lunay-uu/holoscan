#include <memory>
#include <iostream>
#include <vector>
#include "holoscan/holoscan.hpp"

using namespace std;

//global token count
namespace holoscan::conditions {
size_t tok_op1_op2 = 0;  
size_t tok_op1_op3 = 0;  
size_t tok_op2_op3 = 0;  
size_t tok_op3_op4 = 0; 
}


namespace holoscan::conditions {

class SDFSingleEdgeCondition : public Condition {
 public:
  HOLOSCAN_CONDITION_FORWARD_ARGS(SDFSingleEdgeCondition)
  SDFSingleEdgeCondition() = default;

  void initialize() override {
    Condition::initialize();
    current_state_ = SchedulingStatusType::kWait;
    last_state_change_ = 0;
  }

  void setup(ComponentSpec& spec) override {
    spec.param(receiver_,
               "receiver",
               "Receiver",
               "Input channel (for observability only)");
    spec.param(edge_id_,
               "edge_id",
               "Edge ID",
               "Which SDF edge this condition refers to");
    spec.param(min_tokens_,
               "min_tokens",
               "Consume rate b",
               "SDF firing requires tokens(edge) ≥ b",
               static_cast<uint64_t>(1));
  }

  void check(int64_t, SchedulingStatusType* type,
             int64_t* target_timestamp) const override {
    *type = current_state_;
    *target_timestamp = last_state_change_;
  }

  void on_execute(int64_t timestamp) override {
    update_state(timestamp);
  }

  void update_state(int64_t timestamp) override {
    const bool ready = check_ready();
    if (ready && current_state_ != SchedulingStatusType::kReady) {
      current_state_ = SchedulingStatusType::kReady;
      last_state_change_ = timestamp;
    } else if (!ready && current_state_ != SchedulingStatusType::kWait) {
      current_state_ = SchedulingStatusType::kWait;
      last_state_change_ = timestamp;
    }
  }

 private:
  bool check_ready() const {
    size_t tokens = 0;

    switch (edge_id_.get()) {
      case 1: tokens = tok_op1_op2; break;
      case 4: tokens = tok_op3_op4; break;
      default: tokens = 0;
    }

    return tokens >= min_tokens_.get();
  }

  Parameter<std::shared_ptr<holoscan::Receiver>> receiver_;
  Parameter<int> edge_id_;
  Parameter<uint64_t> min_tokens_;

  mutable SchedulingStatusType current_state_ = SchedulingStatusType::kWait;
  mutable int64_t last_state_change_ = 0;
};

}  // namespace holoscan::conditions
namespace holoscan::conditions {

class SDFJoinCondition : public Condition {
 public:
  HOLOSCAN_CONDITION_FORWARD_ARGS(SDFJoinCondition)
  SDFJoinCondition() = default;

  void initialize() override {
    Condition::initialize();
    current_state_ = SchedulingStatusType::kWait;
    last_state_change_ = 0;
  }

  void setup(ComponentSpec& spec) override {
    spec.param(receiver1_,
               "receiver1",
               "Receiver 1",
               "First join input (observability only)");
    spec.param(receiver2_,
               "receiver2",
               "Receiver 2",
               "Second join input (observability only)");
    spec.param(min1_,
               "min1",
               "Consume rate b1",
               "Required tokens on edge 1",
               static_cast<uint64_t>(1));
    spec.param(min2_,
               "min2",
               "Consume rate b2",
               "Required tokens on edge 2",
               static_cast<uint64_t>(1));
  }

  void check(int64_t, SchedulingStatusType* type,
             int64_t* target_timestamp) const override {
    *type = current_state_;
    *target_timestamp = last_state_change_;
  }

  void on_execute(int64_t timestamp) override {
    update_state(timestamp);
  }

  void update_state(int64_t timestamp) override {
    const bool ready = check_ready();
    if (ready && current_state_ != SchedulingStatusType::kReady) {
      current_state_ = SchedulingStatusType::kReady;
      last_state_change_ = timestamp;
    } else if (!ready && current_state_ != SchedulingStatusType::kWait) {
      current_state_ = SchedulingStatusType::kWait;
      last_state_change_ = timestamp;
    }
  }

 private:
  bool check_ready() const {
    const bool in2_ready =
      tok_op1_op3 >= min1_.get();  // Op1 → Op3

    const bool in3_ready =
      tok_op2_op3 >= min2_.get();  // Op2 → Op3

    return in2_ready && in3_ready;
  }

  Parameter<std::shared_ptr<holoscan::Receiver>> receiver1_;
  Parameter<std::shared_ptr<holoscan::Receiver>> receiver2_;
  Parameter<uint64_t> min1_;
  Parameter<uint64_t> min2_;

  mutable SchedulingStatusType current_state_ = SchedulingStatusType::kWait;
  mutable int64_t last_state_change_ = 0;
};

}  // namespace holoscan::conditions

/* =========================================================
 * Op1：双输出 Source
 * ========================================================= */
class Op1 : public holoscan::Operator {
 public:
  HOLOSCAN_OPERATOR_FORWARD_ARGS(Op1)

  void setup(holoscan::OperatorSpec& spec) override {
    spec.output<vector<int>>("out1");
    spec.output<vector<int>>("out2");
  }

  void compute(holoscan::InputContext&, holoscan::OutputContext& out,
               holoscan::ExecutionContext&) override {
    static int c = 0;

    vector<int> to_op2 = {++c, ++c};   // a=2
    vector<int> to_op3 = {++c};        // a=1

    out.emit(to_op2, "out1");
    out.emit(to_op3, "out2");

    holoscan::conditions::tok_op1_op2 += to_op2.size();
    holoscan::conditions::tok_op1_op3 += to_op3.size();

    cout << "Op1 fires\n";
  }
};

/* =========================================================
 * Op2：consume 3 → produce 2
 * ========================================================= */
class Op2 : public holoscan::Operator {
 public:
  HOLOSCAN_OPERATOR_FORWARD_ARGS(Op2)

  void setup(holoscan::OperatorSpec& spec) override {
    spec.input<vector<int>>("in").queue_size(64);
    spec.output<vector<int>>("out");
  }

  void compute(holoscan::InputContext& in, holoscan::OutputContext& out,
               holoscan::ExecutionContext&) override {
    static vector<int> buffer;

    auto msg = in.receive<vector<int>>("in");
    while (msg) {
      buffer.insert(buffer.end(), msg->begin(), msg->end());
      msg = in.receive<vector<int>>("in");
    }

    if (buffer.size() >= 3) {
      buffer.erase(buffer.begin(), buffer.begin() + 3);
      holoscan::conditions::tok_op1_op2 -= 3;

      vector<int> produced = {1, 2};  // a=2
      out.emit(produced, "out");
      holoscan::conditions::tok_op2_op3 += produced.size();

      cout << "Op2 fires\n";
    }
  }
};

/* =========================================================
 * Op3：Join (2 + 3 → 3)
 * ========================================================= */
class Op3 : public holoscan::Operator {
 public:
  HOLOSCAN_OPERATOR_FORWARD_ARGS(Op3)

  void setup(holoscan::OperatorSpec& spec) override {
    spec.input<vector<int>>("in2").queue_size(64);
    spec.input<vector<int>>("in3").queue_size(64);
    spec.output<vector<int>>("out");
  }

  void compute(holoscan::InputContext& in, holoscan::OutputContext& out,
               holoscan::ExecutionContext&) override {
    static vector<int> buf2, buf3;

    auto m2 = in.receive<vector<int>>("in2");
    while (m2) {
      buf2.insert(buf2.end(), m2->begin(), m2->end());
      m2 = in.receive<vector<int>>("in2");
    }

    auto m3 = in.receive<vector<int>>("in3");
    while (m3) {
      buf3.insert(buf3.end(), m3->begin(), m3->end());
      m3 = in.receive<vector<int>>("in3");
    }

    if (buf2.size() >= 2 && buf3.size() >= 3) {
      buf2.erase(buf2.begin(), buf2.begin() + 2);
      buf3.erase(buf3.begin(), buf3.begin() + 3);

      holoscan::conditions::tok_op1_op3 -= 2;
      holoscan::conditions::tok_op2_op3 -= 3;

      vector<int> produced = {1, 2, 3};  // a=3
      out.emit(produced, "out");
      holoscan::conditions::tok_op3_op4 += produced.size();

      cout << "Op3 fires (join)\n";
    }
  }
};

/* =========================================================
 * Op4：Sink (consume 4)
 * ========================================================= */
class Op4 : public holoscan::Operator {
 public:
  HOLOSCAN_OPERATOR_FORWARD_ARGS(Op4)

  void setup(holoscan::OperatorSpec& spec) override {
    spec.input<vector<int>>("in").queue_size(64);
  }

  void compute(holoscan::InputContext& in, holoscan::OutputContext&,
               holoscan::ExecutionContext&) override {
    static vector<int> buffer;

    auto msg = in.receive<vector<int>>("in");
    while (msg) {
      buffer.insert(buffer.end(), msg->begin(), msg->end());
      msg = in.receive<vector<int>>("in");
    }

    if (buffer.size() >= 4) {
      buffer.erase(buffer.begin(), buffer.begin() + 4);
      holoscan::conditions::tok_op3_op4 -= 4;
      cout << "Op4 consumes 4\n";
    }
  }
};

/* =========================================================
 * Application
 * ========================================================= */
class TokenSDFApp : public holoscan::Application {
 public:
  void compose() override {
    using namespace holoscan;

    auto op1 = make_operator<Op1>(
      "op1", make_condition<CountCondition>("count", 20));

auto cond2 = make_condition<conditions::SDFSingleEdgeCondition>(
  "cond2",
  Arg("receiver", "in"),
  Arg("edge_id", 1),
  Arg("min_tokens", uint64_t(3)));

auto cond3 = make_condition<conditions::SDFJoinCondition>(
  "cond3",
  Arg("receiver1", "in2"),
  Arg("receiver2", "in3"),
  Arg("min1", uint64_t(2)),
  Arg("min2", uint64_t(3)));

auto cond4 = make_condition<conditions::SDFSingleEdgeCondition>(
  "cond4",
  Arg("receiver", "in"),
  Arg("edge_id", 4),
  Arg("min_tokens", uint64_t(4)));


    add_flow(op1, op2, {{"out1", "in"}});
    add_flow(op1, op3, {{"out2", "in2"}});
    add_flow(op2, op3, {{"out",  "in3"}});
    add_flow(op3, op4, {{"out",  "in"}});
  }
};

/* =========================================================
 * Main
 * ========================================================= */
int main() {
  auto app = holoscan::make_application<TokenSDFApp>();
  app->run();
  return 0;
}
