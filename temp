#include <memory>
#include <iostream>
#include <vector>
#include "holoscan/holoscan.hpp"

using namespace std;

//global token count
namespace holoscan::conditions {
size_t tok_op1_op2 = 0;  
size_t tok_op1_op3 = 0;  
size_t tok_op2_op3 = 0;  
size_t tok_op3_op4 = 0; 
}


namespace holoscan::conditions {

class BufferAwareCondition : public Condition {
 public:
  HOLOSCAN_CONDITION_FORWARD_ARGS(BufferAwareCondition)
  BufferAwareCondition() = default;

  void initialize() override {
    Condition::initialize();
    current_state_ = SchedulingStatusType::kWait;
    last_state_change_ = 0;
  }

  void setup(ComponentSpec& spec) override {
    spec.param(receiver_,
               "receiver",
               "Receiver",
               "Input channel to monitor for message availability.");
    spec.param(edge_id_,
               "edge_id",
               "Edge ID",
               "indicates edge");
    spec.param(min_tokens_,
               "min_tokens",
               "Minimum total tokens required",
               "Condition READY when queue + buffer ≥ min_tokens",
               static_cast<uint64_t>(1));
  }

  void check(int64_t, SchedulingStatusType* type,
             int64_t* target_timestamp) const override {
    *type = current_state_;
    *target_timestamp = last_state_change_;
  }

  void on_execute(int64_t timestamp) override {
    update_state(timestamp);
  }

  void update_state(int64_t timestamp) override {
    const bool ready = check_ready();
    if (ready && current_state_ != SchedulingStatusType::kReady) {
      current_state_ = SchedulingStatusType::kReady;
      last_state_change_ = timestamp;
    } else if (!ready && current_state_ != SchedulingStatusType::kWait) {
      current_state_ = SchedulingStatusType::kWait;
      last_state_change_ = timestamp;
    }
  }

 private:
  bool check_ready() const {
    size_t tokens = 0;

    switch (edge_id_.get()) {
      case 1: tokens = tok_op1_op2; break;
      case 4: tokens = tok_op3_op4; break;
      default: tokens = 0;
    }

    return tokens >= min_tokens_.get();
  }

  Parameter<std::shared_ptr<holoscan::Receiver>> receiver_;
  Parameter<int> edge_id_;
  Parameter<uint64_t> min_tokens_;

  mutable SchedulingStatusType current_state_ = SchedulingStatusType::kWait;
  mutable int64_t last_state_change_ = 0;
};

}  
namespace holoscan::conditions {

class JoinCondition : public Condition {
 public:
  HOLOSCAN_CONDITION_FORWARD_ARGS(JoinCondition)
  JoinCondition() = default;

  void initialize() override {
    Condition::initialize();
    current_state_ = SchedulingStatusType::kWait;
    last_state_change_ = 0;
  }

  void setup(ComponentSpec& spec) override {
    spec.param(receiver1_,
               "receiver1",
               "Receiver 1",
               "First join input");
    spec.param(receiver2_,
               "receiver2",
               "Receiver 2",
               "Second join input");
    spec.param(min1_,
               "min1",
               "Consume rate b1",
               "Required tokens on edge 1",
               static_cast<uint64_t>(1));
    spec.param(min2_,
               "min2",
               "Consume rate b2",
               "Required tokens on edge 2",
               static_cast<uint64_t>(1));
  }

  void check(int64_t, SchedulingStatusType* type,
             int64_t* target_timestamp) const override {
    *type = current_state_;
    *target_timestamp = last_state_change_;
  }

  void on_execute(int64_t timestamp) override {
    update_state(timestamp);
  }

  void update_state(int64_t timestamp) override {
    const bool ready = check_ready();
    if (ready && current_state_ != SchedulingStatusType::kReady) {
      current_state_ = SchedulingStatusType::kReady;
      last_state_change_ = timestamp;
    } else if (!ready && current_state_ != SchedulingStatusType::kWait) {
      current_state_ = SchedulingStatusType::kWait;
      last_state_change_ = timestamp;
    }
  }

 private:
  bool check_ready() const {
    const bool in2_ready =
      tok_op1_op3 >= min1_.get(); 

    const bool in3_ready =
      tok_op2_op3 >= min2_.get();  

    return in2_ready && in3_ready;
  }

  Parameter<std::shared_ptr<holoscan::Receiver>> receiver1_;
  Parameter<std::shared_ptr<holoscan::Receiver>> receiver2_;
  Parameter<uint64_t> min1_;
  Parameter<uint64_t> min2_;

  mutable SchedulingStatusType current_state_ = SchedulingStatusType::kWait;
  mutable int64_t last_state_change_ = 0;
};

}  


class Op1 : public holoscan::Operator {
 public:
  HOLOSCAN_OPERATOR_FORWARD_ARGS(Op1)
  Op1() = default;

  void setup(holoscan::OperatorSpec& spec) override {
    spec.output<std::vector<int>>("out1");
    spec.output<std::vector<int>>("out2");

    spec.param(a1_, "a1", "Tokens out1", "Tokens produced on out1 per fire", 2);
    spec.param(a2_, "a2", "Tokens out2", "Tokens produced on out2 per fire", 1);
  }

  void compute(holoscan::InputContext&, holoscan::OutputContext& out,
               holoscan::ExecutionContext&) override {
    static int counter = 0;

    std::vector<int> b1;
    b1.reserve(a1_.get());
    for (int i = 0; i < a1_.get(); ++i)
      b1.push_back(++counter);

    std::vector<int> b2;
    b2.reserve(a2_.get());
    for (int i = 0; i < a2_.get(); ++i)
      b2.push_back(++counter);

    out.emit(b1, "out1");
    out.emit(b2, "out2");

    holoscan::conditions::tok_op1_op2 += b1.size();
    holoscan::conditions::tok_op1_op3 += b2.size();

    std::cout << "Op1 produces out1:";
    for (auto v : b1) std::cout << " " << v;
     std::cout <<  std::endl;
      std::cout << "Op1 produces out2:";
    for (auto v : b2) std::cout << " " << v;
     std::cout <<  std::endl;
  }

 private:
  holoscan::Parameter<int> a1_;
  holoscan::Parameter<int> a2_;
};


class Op2 : public holoscan::Operator {
 public:
  HOLOSCAN_OPERATOR_FORWARD_ARGS(Op2)
  Op2() = default;

  void setup(holoscan::OperatorSpec& spec) override {
    spec.input<std::vector<int>>("in").queue_size(64);
    spec.output<std::vector<int>>("out");

    spec.param(b1_, "b1", "Consume rate", "Tokens consumed per fire", 3);
    spec.param(a3_, "a3", "Produce rate", "Tokens produced per fire", 2);
  }

  void compute(holoscan::InputContext& in, holoscan::OutputContext& out,
               holoscan::ExecutionContext&) override {
    static std::vector<int> buffer;

    auto msg = in.receive<std::vector<int>>("in");
    while (msg) {
      buffer.insert(buffer.end(), msg->begin(), msg->end());
      msg = in.receive<std::vector<int>>("in");
    }

    if (buffer.size() >= static_cast<size_t>(b1_.get())) {
       std::cout << "Op2 consumes:";
      for (int i = 0; i < b1_.get(); ++i) std::cout << " " << buffer[i];
      std::cout << std::endl;
      buffer.erase(buffer.begin(), buffer.begin() + b1_.get());
      holoscan::conditions::tok_op1_op2 -= b1_.get();

      std::vector<int> produced;
      produced.reserve(a3_.get());
      for (int i = 0; i < a3_.get(); ++i)
        produced.push_back(i);

      out.emit(produced, "out");
      holoscan::conditions::tok_op2_op3 += produced.size();

          std::cout << "Op2 produces :";
    for (auto v : produced) std::cout << " " << v;
     std::cout <<  std::endl;
    }
  }

 private:
  holoscan::Parameter<int> b1_;
  holoscan::Parameter<int> a3_;
};


class Op3 : public holoscan::Operator {
 public:
  HOLOSCAN_OPERATOR_FORWARD_ARGS(Op3)
  Op3() = default;

  void setup(holoscan::OperatorSpec& spec) override {
    spec.input<std::vector<int>>("in2").queue_size(64);
    spec.input<std::vector<int>>("in3").queue_size(64);
    spec.output<std::vector<int>>("out");

    spec.param(b2_, "b2", "Consume in2", "Tokens consumed from in2", 2);
    spec.param(b3_, "b3", "Consume in3", "Tokens consumed from in3", 3);
    spec.param(a4_, "a4", "Produce out", "Tokens produced per fire", 3);
  }

  void compute(holoscan::InputContext& in, holoscan::OutputContext& out,
               holoscan::ExecutionContext&) override {
    static std::vector<int> buf2, buf3;

    auto m2 = in.receive<std::vector<int>>("in2");
    while (m2) {
      buf2.insert(buf2.end(), m2->begin(), m2->end());
      m2 = in.receive<std::vector<int>>("in2");
    }

    auto m3 = in.receive<std::vector<int>>("in3");
    while (m3) {
      buf3.insert(buf3.end(), m3->begin(), m3->end());
      m3 = in.receive<std::vector<int>>("in3");
    }

    if (buf2.size() >= static_cast<size_t>(b2_.get()) &&
        buf3.size() >= static_cast<size_t>(b3_.get())) {
std::cout << "Op3 consumes in1:";
for (int i = 0; i <  b2_.get(); ++i) std::cout << " " << buf2[i];
std::cout << std::endl;
std::cout << "Op3 consumes in2:";
for (int i = 0; i <  b3_.get(); ++i) std::cout << " " << buf3[i];
std::cout << std::endl;
      buf2.erase(buf2.begin(), buf2.begin() + b2_.get());
      buf3.erase(buf3.begin(), buf3.begin() + b3_.get());

      holoscan::conditions::tok_op1_op3 -= b2_.get();
      holoscan::conditions::tok_op2_op3 -= b3_.get();

      std::vector<int> produced;
      produced.reserve(a4_.get());
      for (int i = 0; i < a4_.get(); ++i)
        produced.push_back(i);

      out.emit(produced, "out");
      holoscan::conditions::tok_op3_op4 += produced.size();

              std::cout << "Op3 produces :";
    for (auto v : produced) std::cout << " " << v;
     std::cout <<  std::endl;
    }
  }

 private:
  holoscan::Parameter<int> b2_;
  holoscan::Parameter<int> b3_;
  holoscan::Parameter<int> a4_;
};

class Op4 : public holoscan::Operator {
 public:
  HOLOSCAN_OPERATOR_FORWARD_ARGS(Op4)
  Op4() = default;

  void setup(holoscan::OperatorSpec& spec) override {
    spec.input<std::vector<int>>("in").queue_size(64);
    spec.param(b4_, "b4", "Consume rate", "Tokens consumed per fire", 4);
  }

  void compute(holoscan::InputContext& in, holoscan::OutputContext&,
               holoscan::ExecutionContext&) override {
    static std::vector<int> buffer;

    auto msg = in.receive<std::vector<int>>("in");
    while (msg) {
      buffer.insert(buffer.end(), msg->begin(), msg->end());
      msg = in.receive<std::vector<int>>("in");
    }

    if (buffer.size() >= static_cast<size_t>(b4_.get())) {
std::cout << "Op4 consumes in3:";
for (int i = 0; i <  b4_.get(); ++i) std::cout << " " << buffer[i];
std::cout << std::endl;
      buffer.erase(buffer.begin(), buffer.begin() + b4_.get());
      holoscan::conditions::tok_op3_op4 -= b4_.get();
  
    }
  }

 private:
  holoscan::Parameter<int> b4_;
};



class TokenSDFApp : public holoscan::Application {
 public:
  void compose() override {
    using namespace holoscan;

    auto op1 = make_operator<Op1>(
      "op1",
      make_condition<CountCondition>("count", 20),
      Arg("a1", 2),   // Op1 → Op2 : a1 = 2
      Arg("a2", 1)    // Op1 → Op3 : a2 = 1
    );

    auto cond2 = make_condition<conditions::BufferAwareCondition>(
      "cond2",
      Arg("receiver", "in"),
      Arg("edge_id", 1),          // tok_op1_op2
      Arg("min_tokens", uint64_t(3))  // b1 = 3
    );

    auto op2 = make_operator<Op2>(
      "op2",
      cond2,
      Arg("b1", 3),   // consume 3
      Arg("a3", 2)    // produce 2
    );

  
    auto cond3 = make_condition<conditions::JoinCondition>(
      "cond3",
      Arg("receiver1", "in2"),
      Arg("receiver2", "in3"),
      Arg("min1", uint64_t(2)),   // Op1 → Op3 consume
      Arg("min2", uint64_t(3))    // Op2 → Op3 consume
    );

    auto op3 = make_operator<Op3>(
      "op3",
      cond3,
      Arg("b2", 2),   // consume from in2
      Arg("b3", 3),   // consume from in3
      Arg("a4", 3)    // produce
    );

   
    auto cond4 = make_condition<conditions::BufferAwareCondition>(
      "cond4",
      Arg("receiver", "in"),
      Arg("edge_id", 4),          // tok_op3_op4
      Arg("min_tokens", uint64_t(4))  // b4 = 4
    );

    auto op4 = make_operator<Op4>(
      "op4",
      cond4,
      Arg("b4", 4)
    );


    add_flow(op1, op2, {{"out1", "in"}});
    add_flow(op1, op3, {{"out2", "in2"}});
    add_flow(op2, op3, {{"out",  "in3"}});
    add_flow(op3, op4, {{"out",  "in"}});
  }
};



int main() {
  auto app = holoscan::make_application<TokenSDFApp>();
  app->run();
  return 0;
}
